## 1. Symp

**a framework from a parallel reality where symbols won.**

---

### ğŸ”® Philosophy

**What if programming evolved around meaning instead of machines?**  
Symp is a minimalist symbolic framework that re-imagines computing as a dialogue between **form** and **meaning**.  
A small, strange, and honest system â€” from a world where *symbols* triumphed over *flashing lights*.

---

### ğŸ’¡ The Idea

In Symp, every computation follows one simple ritual:

```

input â†’ syntax â†’ semantics â†’ output

````

Instead of a compiler that hides these stages,  
Symp makes each one **programmable**.

You donâ€™t just write programs in Symp â€”  
you define *how* programs themselves should be understood.

---

### ğŸ§  Why Symp Exists

Symp isnâ€™t a Lisp dialect or a new syntax flavor.  
Itâ€™s a **computational philosophy**:

* Programs prove their *form* before they express their *meaning*.
* Syntax and semantics are equals â€” two halves of a single act.
* Everything can be described in its own language.

Itâ€™s deliberately colorless, minimalist, and transparent.  
A tool for anyone who loves **building languages more than writing in them**.

---

### ğŸš€ What You Can Build

Symp is tiny, but composable.  
Itâ€™s a playground for symbolic systems:

* Custom DSLs and interpreters
* Meta-compilers and term rewriters
* Theorem provers, logic engines, or exotic REPLs

Anything that can be described as â€œaction â†’ form â†’ meaning â†’ reactionâ€.

---

### âœ¨ A Thought Experiment

*â€œWhat if computers had never chased graphics?  
What if clarity of expression had guided evolution instead?â€*

Symp comes from that alternate timeline.
Itâ€™s small, honest, and built for people who enjoy the elegance of theory.

---

### ğŸ“š Learn More

* [Foundations](docs/foundations.md)
* The Three Pillars
  * [Symbolmatch](docs/symbolmatch.md)
  * [Symbolverse](docs/symbolverse.md)
  * [Symbolprose](docs/symbolprose.md)
* [Examples](docs/examples.md)
* [Conclusion](docs/conclusion.md)

---

### ğŸ–¤ Inspiration

Symp is inspired by Lisp, PEGs, term rewriting systems, and finite state machines.
