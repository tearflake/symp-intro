## 1. Symp

**a framework from a parallel reality where symbols won.**

---

### 🔮 Philosophy

What if programming had evolved around **form** and **meaning** rather than machinery?

Syntax defines a form of expressions.  
Semantics decides what they mean.  
Execution connects the two.

Symp is a small, strange, and honest framework evolved from form and meaning.  
It carries a *thought experiment* from a reality in which symbols triumphed over flashing lights.

---

### 💡 The Idea

In Symp, every computation follows one simple ritual:

```

input → syntax → semantics → output

````

Instead of a compiler that hides these stages,  
Symp makes each one **programmable**.

You don’t just write programs in Symp —  
you define *how* programs themselves should be understood.

---

### 🧠 Why Symp Exists

Symp isn’t a Lisp dialect or a new syntax flavor.  
It’s a **computational philosophy**:

* Programs prove their *form* before they express their *meaning*.
* Syntax and semantics are equals — two halves of a single act.
* Everything can be described in its own language.

It’s deliberately colorless, minimalist, and transparent.  
A tool for anyone who loves **building languages more than writing in them**.

---

### 🚀 What You Can Build

Symp is tiny, but composable.  
It’s a playground for symbolic systems:

* Custom DSLs and interpreters
* Meta-compilers and term rewriters
* Theorem provers, logic engines, or exotic REPLs

Anything that can be described as “action → form → meaning → reaction”.

---

### 📚 Learn More

* [Foundations](docs/foundations.md)
* The Three Pillars
  * [Symbolmatch](docs/symbolmatch.md)
  * [Symbolverse](docs/symbolverse.md)
  * [Symbolprose](docs/symbolprose.md)
* [Examples](docs/examples.md)
* [Conclusion](docs/conclusion.md)

---

### 🖤 Inspiration

Symp is inspired by Lisp, PEGs, term rewriting systems, and finite state machines.
