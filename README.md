## 1. Symp

**a framework from a parallel reality where symbols won.**

---

### ğŸ”® Philosophy

What if programming had evolved around **form** and **meaning** rather than machinery?

Syntax defines a form of expressions.  
Semantics decides what they mean.  
Execution connects the two.

Symp is a small, strange, and honest framework evolved from form and meaning.  
It carries a *thought experiment* from a reality in which symbols triumphed over flashing lights.

---

### ğŸ’¡ The Idea

In Symp, every computation follows one simple ritual:

```

input â†’ syntax â†’ semantics â†’ output

````

Instead of a compiler that hides these stages,  
Symp makes each one **programmable**.

You donâ€™t just write programs in Symp â€”  
you define *how* programs themselves should be understood.

---

### ğŸ§  Why Symp Exists

Symp isnâ€™t a Lisp dialect or a new syntax flavor.  
Itâ€™s a **computational philosophy**:

* Programs prove their *form* before they express their *meaning*.
* Syntax and semantics are equals â€” two halves of a single act.
* Everything can be described in its own language.

Itâ€™s deliberately colorless, minimalist, and transparent.  
A tool for anyone who loves **building languages more than writing in them**.

---

### ğŸš€ What You Can Build

Symp is tiny, but composable.  
Itâ€™s a playground for symbolic systems:

* Custom DSLs and interpreters
* Meta-compilers and term rewriters
* Theorem provers, logic engines, or exotic REPLs

Anything that can be described as â€œaction â†’ form â†’ meaning â†’ reactionâ€.

---

### ğŸ“š Learn More

* [Foundations](docs/foundations.md)
* The Three Pillars
  * [Symbolmatch](docs/symbolmatch.md)
  * [Symbolverse](docs/symbolverse.md)
  * [Symbolprose](docs/symbolprose.md)
* [Examples](docs/examples.md)
* [Conclusion](docs/conclusion.md)

---

### ğŸ–¤ Inspiration

Symp is inspired by Lisp, PEGs, term rewriting systems, and finite state machines.
