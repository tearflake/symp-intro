## 1. Symp

**a framework from a parallel reality where symbols won.**

---

### 🔮 Philosophy

**What if programming evolved around meaning instead of machines?**  
Symp is a minimalist symbolic framework that re-imagines computing as a dialogue between **form** and **meaning**.  
A small, strange, and honest system — from a world where *symbols* triumphed over *flashing lights*.

---

### 💡 The Idea

In Symp, every computation follows one simple ritual:

```

input → syntax → semantics → output

````

Instead of a compiler that hides these stages,  
Symp makes each one **programmable**.

You don’t just write programs in Symp —  
you define *how* programs themselves should be understood.

---

### 🧠 Why Symp Exists

Symp isn’t a Lisp dialect or a new syntax flavor.  
It’s a **computational philosophy**:

* Programs prove their *form* before they express their *meaning*.
* Syntax and semantics are equals — two halves of a single act.
* Everything can be described in its own language.

It’s deliberately colorless, minimalist, and transparent.  
A tool for anyone who loves **building languages more than writing in them**.

---

### 🚀 What You Can Build

Symp is tiny, but composable.  
It’s a playground for symbolic systems:

* Custom DSLs and interpreters
* Meta-compilers and term rewriters
* Theorem provers, logic engines, or exotic REPLs

Anything that can be described as “action → form → meaning → reaction”.

---

### ✨ A Thought Experiment

*“What if computers had never chased graphics?  
What if clarity of expression had guided evolution instead?”*

Symp comes from that alternate timeline.
It’s small, honest, and built for people who enjoy the elegance of theory.

---

### 📚 Learn More

* [Foundations](docs/foundations.md)
* The Three Pillars
  * [Symbolmatch](docs/symbolmatch.md)
  * [Symbolverse](docs/symbolverse.md)
  * [Symbolprose](docs/symbolprose.md)
* [Examples](docs/examples.md)
* [Conclusion](docs/conclusion.md)

---

### 🖤 Inspiration

Symp is inspired by Lisp, PEGs, term rewriting systems, and finite state machines.
